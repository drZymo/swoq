@page "/doc/"

@rendermode InteractiveServer

@using Markdig
@using Swoq.Data
@using System.Text.RegularExpressions

@inject ISwoqDatabase Database
@inject IWebHostEnvironment webHostEnvironment
@inject UserService UserService

<PageTitle>SWOQ - Documentation</PageTitle>

<style>
	table {
		margin-left: 10pt;
		border-style: solid;
		border-width: 1px;
	}

	th {
		background-color: rgb(243, 243, 243);
		padding: 4pt;
	}

	td {
		padding: 4pt;
	}

</style>

<div class="documentation-container">
	@((MarkupString)(Markdown.ToHtml(DocumentationContent, new MarkdownPipelineBuilder().UseAdvancedExtensions().Build())))

	<br />
	<br />
</div>

@code {
	public string DocumentationContent { get; set; } = string.Empty;

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			try
			{
				var userId = await UserService.GetUserIdAsync();
				var currentUser = await Database.FindUserByIdAsync(userId);
				DocumentationContent = GetDocumentationContent(currentUser?.Level ?? 0);
				StateHasChanged();
			}
			catch
			{
				DocumentationContent = "No user logged in";
			}

		}
	}

	private static readonly Regex LevelPattern = new Regex(@"^# Level (\d+) and higher$");

	private string GetDocumentationContent(int Level)
	{
		try
		{
			// Read full proto file
			var path = Path.Combine(webHostEnvironment.WebRootPath, "swoq.md");
			var lines = File.ReadAllLines(path);

			// Filer out all lines of too high levels
			var filtered = new List<string>();
			bool hide = false;
			foreach (var line in lines)
			{
				var filteredLine = line;
				if (!hide)
				{
					// Check if line defines level
					var match = LevelPattern.Match(line);
					if (match.Success)
					{
						var lineLevel = int.Parse(match.Groups[1].Value);

						// Level too high, then hide from here
						if (lineLevel > Level) hide = true;

						if (lineLevel == Level)
						{
							filteredLine = $"{filteredLine} (✨ New ✨)";
						}
					}
				}

				if (hide) break;

				filtered.Add(filteredLine);
			}

			return string.Join("\n", filtered);
		}
		catch
		{
			return "";
		}
	}
}
